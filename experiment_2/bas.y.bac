%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define YYSTYPE char *

extern int yylex();
extern int yylineno;
extern char *yytext;

void yyerror(char const *s) {
    fprintf(stderr, "line %d: %s\n", yylineno, s);
}

struct tag {
    char *name;
    char *text;
};

struct tag_stack {
    struct tag *tag;
    struct tag_stack *next;
};

struct tag_stack *stack = NULL;

void push_tag(struct tag *t) {
    struct tag_stack *node = malloc(sizeof(struct tag_stack));
    node->tag = t;
    node->next = stack;
    stack = node;
}

struct tag *pop_tag() {
    struct tag_stack *node = stack;
    stack = node->next;
    struct tag *tag = node->tag;
    free(node);
    return tag;
}

%}

%token TAG_START
%token TAG_END
%token TEXT
%token INVALID_TAG

%union {
    char *str;
}

%type <str> tag_name
%type <str> tag_text

%%

input:
    | input tag
    ;

tag:
    TAG_START tag_name TAG_END tag_content "</>"      {
                                                          struct tag *t = malloc(sizeof(struct tag));
                                                          t->name = $2;
                                                          t->text = $4;
                                                          push_tag(t);
                                                      }
    | INVALID_TAG                                     {
                                                          fprintf(stderr, "Invalid tag: %s\n", $1);
                                                          free($1);
                                                      }
    ;

tag_content:
    | TEXT tag_content                                {
                                                          if ($1 != NULL) {
                                                              if (stack != NULL) {
                                                                  stack->tag->text = realloc(stack->tag->text, strlen(stack->tag->text) + strlen($1) + 1);
                                                                  strcat(stack->tag->text, $1);
                                                              }
                                                              free($1);
                                                          }
                                                      }
    ;

tag_name:
    TAG_START <str>           { $$ = $2; }
    ;

tag_text:
    tag_content           {
                              $$ = $1;
                              if (stack != NULL) {
                                  stack->tag->text = realloc(stack->tag->text, strlen(stack->tag->text) + strlen($1) + 1);
                                  strcat(stack->tag->text, $1);
                              }
                          }
    ;

%%

int main() {
    yyparse();
    struct tag *t;
    while ((t = pop_tag()) != NULL) {
        printf("<%s>%s</%s>\n", t->name, t->text, t->name);
        free(t->name);
        free(t->text);
        free(t);
    }
    return 0;
}

int yywrap() {
    return 1;
}

int yylex() {
    int c = getchar();
    if (c == '<') {
        char buf[256];
        int i = 0;
        while (i < 255 && (c = getchar()) != '>') {
            buf[i++] = c;
        }
        if (i >= 255) {
            fprintf(stderr, "Tag name too long\n");
            exit(1);
        }
        buf[i] = '\0';
        yylval.str = strdup(buf);
        return TAG_START;
    } else if (c == '/') {
        int c2 = getchar();
        if (c2 == '>') {
            return TAG_START "/>";
        } else {
            fprintf(stderr, "Invalid tag\n");
            exit(1);
        }
    } else if (c == EOF) {
        return 0;
    } else {
        char buf[256];
        int i = 0;
        buf[i++] = c;
        while ((c = getchar()) != EOF && c != '<') {
            buf[i++] = c;
        }
        buf[i] = '\0';
        yylval.str = strdup(buf);
        return TEXT;
    }
}
